# 前因
> 为什么会出现用户态内核态

- 首先拿Linux服务器分层架构来讲，分为这几个部分：
	1. 内核：是控制计算机硬件的底层软件，并对系统调用提供接口访问。
	2. 系统调用：看作操作系统的最小功能单位，可以理解成一个不能再简化的操作，去调用内核提供的接口进行操作。
	3. 库函数：可以理解为对系统调用的封装，如果把系统调用必做笔画，那么库函数就是属于偏旁部首。
	4. shell：可以看作特殊的应用程序，应用调用他执行的时候可以去直接去跑系统调用，充当一种胶水来粘合各种小功能。
	5. 应用程序：就是我们平时开发出来的业务代码。

# 概念
- Linux内核态：向下管理硬件资源，向内管理操作系统资源：包括进程调度管理，内存管理，文件系统管理，设备驱动管理。
- Linux用户态：当进程执行自己代码时候，就是处于用户态，运行在用户态的进程可以利用的资源是有限的。

# 为什么要去分内核态和用户态
- 在操作系统中系统资源有限，访问资源操作过多会消耗很多资源，如果不对这些操作加以区分，会造作资源冲突，需要紧急执行的事情得不到执行。所以需要对不同的操作区分执行等级。Linux分为0和3两个特权集，分别对应内核态和用户态，运行于内核态的进程在利用资源上没有限制，用户态会有限制。

# 用户态内核态切换
- 程序刚开始运行是在用户态，当做一些比如申请内存的操作时就会需要进行系统调用来分配内存，这个过程就设计到用户态到内核态的切换。

	需要进行切换的场景
	1. 系统调用。
	2. 异常事件。
	3. 中断信号。
- **每个进程有两个栈，分别用于内核态和用户态的进程执行**。
	
	用户台到内核态切换过程需要做的事情
	
		需要了解的几个概念：
		tr寄存器:
		
	 
	1.  


# Linux中特殊的1号进程


### 参考阅读：
1.	<https://www.cnblogs.com/bakari/p/5520860.html>
2. <https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html>
3. <https://www.cnblogs.com/lirong21/p/4213028.html>
	